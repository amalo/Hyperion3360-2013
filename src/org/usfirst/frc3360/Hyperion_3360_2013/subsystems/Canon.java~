// RobotBuilder Version: 0.0.2
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
package org.usfirst.frc3360.Hyperion_3360_2013.subsystems;
import org.usfirst.frc3360.Hyperion_3360_2013.RobotMap;
import org.usfirst.frc3360.Hyperion_3360_2013.commands.*;
import edu.wpi.first.wpilibj.*;
import edu.wpi.first.wpilibj.command.Subsystem;
/**
 *
 */
public class Canon extends Subsystem {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    SpeedController canon_SpinnerMotor = RobotMap.canonCanon_SpinnerMotor;
    DoubleSolenoid shooterSolenoid = RobotMap.canonShooterSolenoid;
    DigitalInput limitSwitchCharged1 = RobotMap.canonLimitSwitchCharged1;
    DigitalInput limitSwitchCharged2 = RobotMap.canonLimitSwitchCharged2;
    DoubleSolenoid chargerSolenoid = RobotMap.canonChargerSolenoid;
    DoubleSolenoid setShooterAngle = RobotMap.canonSetShooterAngle;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private boolean m_bChargeReturnRequest;
    private boolean m_bChargeFrisbeeRequest;
    private boolean m_bShootFrisbeeRequest;
    private boolean m_bSpinning;
    private int m_ShootingAngle;
    //
    // Spinning state
    private long m_SpinStartTime;
    // Charging state
    private long m_ChargeStartTime;
    private boolean m_bCharging;
    private boolean m_bChargerReturning;
    // Shooting state
    private boolean m_bShoot;
    private long m_ShootTimeMs;
    //angle request
    private boolean m_bAngleRequest;
    // Private 
    private final DoubleSolenoid.Value m_chargeOn = DoubleSolenoid.Value.kForward;
    private final DoubleSolenoid.Value m_chargeOff = DoubleSolenoid.Value.kReverse;
    private final DoubleSolenoid.Value m_ShooterAngle1 = DoubleSolenoid.Value.kForward;
    private final DoubleSolenoid.Value m_ShooterAngle2 = DoubleSolenoid.Value.kReverse;
    private final DoubleSolenoid.Value m_ShooterPushFrisbeePosition = DoubleSolenoid.Value.kReverse;
    private final DoubleSolenoid.Value m_ShooterPullFrisbeePosition = DoubleSolenoid.Value.kForward;
    private final long m_PullBackShooterTimeMs = 400;
    private final long m_NextShotDelayMs = 1500;
    private final long m_ChargeTimeoutMs = 3000;
    private final long m_SpinningTimeForFirstShootMs = 2000;
    private final double m_ChargerHomeAngle = 0;
    private final double m_MaxAngleDirection = 1;
    private final double m_MinAngleDirection = -1;
    private final double m_AngleTolerance = 2;
    public Canon() {
        // Request the charger to its home position at the begining.
        m_bChargeReturnRequest = true;
        // No command must be executed at the begining.
        m_bChargeFrisbeeRequest = false;
        m_bShootFrisbeeRequest = false;
        m_bSpinning = false;
        m_bAngleRequest = false;
        // Set the default state.
        m_ShootingAngle = 0;
        m_SpinStartTime = 0;
        m_ChargeStartTime = 0;
        m_bCharging = false;
        m_bChargerReturning = false;
        m_bShoot = false;
        m_ShootTimeMs = 0;
        // Set the actuator in the good state.
        canon_SpinnerMotor.set(0);
        shooterSolenoid.set(m_ShooterPullFrisbeePosition);
    }
    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
        setDefaultCommand(new DefaultCanonHandler());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
    }
    // Public control methods
    public void ForceChargeReturn() {
        m_bChargeReturnRequest = true;
    }
    public void ChargeFrisbee() {
        m_bChargeFrisbeeRequest = true;
    }
    public void ShootFrisbee() {
        m_bShootFrisbeeRequest = true;
    }
    public void SetShooterAngle(int angle) {
        m_ShootingAngle = angle;
        m_bAngleRequest = true;
    }
    public void SetSpinnerSpeed(boolean spinning) {
        m_bSpinning = spinning;
    }
    // Internal canon handlers
    public void HandleShoot() {
        boolean bShot = false;
        long shotTimeElapsed = System.currentTimeMillis() - m_ShootTimeMs;
        if (m_bShootFrisbeeRequest) {
            m_bShootFrisbeeRequest = false;
            bShot = CanShoot();
        }
        if (m_bShoot && shotTimeElapsed > m_PullBackShooterTimeMs) {
            // Pullback the solenoid after a shot, but only after a short delay
            shooterSolenoid.set(m_ShooterPullFrisbeePosition);
            m_bShoot = false;
        } else if (bShot && !m_bShoot) {
            // Push the frisbee with the solenoid to perform a shot.
            shooterSolenoid.set(m_ShooterPushFrisbeePosition);
            m_bShoot = true;
            m_ShootTimeMs = System.currentTimeMillis();
        }
    }
    public void HandleShooterAngle() {
        if (m_bAngleRequest) {
            m_bAngleRequest = false;
            switch (m_ShootingAngle) {
                case (1): {
                    setShooterAngle.set(m_ShooterAngle1);
                    break;
                }
                case (2): {
                    setShooterAngle.set(m_ShooterAngle2);
                    break;
                }
            }
        }
    }
    public void HandleCharger() {
        if (m_bChargeFrisbeeRequest) /*&& !IsCharged())*/ {
            m_bChargeFrisbeeRequest = false;
            chargerSolenoid.set(m_chargeOn);
            Timer.delay(0.5);
            chargerSolenoid.set(m_chargeOff);
        }
    }
    public void HandleSpinner() {
        if (m_bSpinning && canon_SpinnerMotor.get() != 1) {
            // Start the spinner.
            canon_SpinnerMotor.set(1);
            m_SpinStartTime = System.currentTimeMillis();
        } else if (!m_bSpinning) {
            // Stop the spinner.
            canon_SpinnerMotor.set(0);
        }
    }
    // Helpers
    private boolean CanShoot() {        
        long spinningTimeElapsed = System.currentTimeMillis() - m_SpinStartTime;
        long timeSinceLastShot = System.currentTimeMillis() - m_ShootTimeMs;        
        System.out.println(spinningTimeElapsed);
        return /* Must be spinning */ m_bSpinning
                && /* Must be spinning for at least X second */ (spinningTimeElapsed > m_SpinningTimeForFirstShootMs)
                && /* Must not have shoot since X second */ (timeSinceLastShot > m_NextShotDelayMs);
             //   && /* There must be a frisbee available */ IsCharged();
    }
   // private boolean IsCharged() {
     //   return limitSwitchCharged1.get() && limitSwitchCharged2.get();
   // }
}
